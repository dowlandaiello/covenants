use cw2::set_contract_version;
use cosmwasm_std::{entry_point, DepsMut, Env, MessageInfo, Response, Deps, StdResult, Binary, to_binary, StdError};
use neutron_sdk::{NeutronResult, NeutronError};
use neutron_sdk::bindings::msg::NeutronMsg;
use neutron_sdk::interchain_txs::helpers::get_port_id;
use serde::{Serialize, Deserialize};
use schemars::JsonSchema;

use crate::msg::{InstantiateMsg, ExecuteMsg, QueryMsg};
use crate::state::{STRIDE_ATOM_RECEIVER, CLOCK_ADDRESS, NATIVE_ATOM_RECEIVER, INTERCHAIN_ACCOUNTS, ICS_PORT_ID};

// Default timeout for SubmitTX is two weeks
const DEFAULT_TIMEOUT_SECONDS: u64 = 60 * 60 * 24 * 7 * 2;

const CONTRACT_NAME: &str = "crates.io:stride-depositor";
const CONTRACT_VERSION: &str = env!("CARGO_PKG_VERSION");

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
struct OpenAckVersion {
    version: String,
    controller_connection_id: String,
    host_connection_id: String,
    address: String,
    encoding: String,
    tx_type: String,
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -> NeutronResult<Response<NeutronMsg>> {
    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;

    // can we do better with validation here?
    deps.api.addr_validate(&msg.st_atom_receiver.address)?;
    deps.api.addr_validate(&msg.atom_receiver.address)?;

    // TODO: consider re-enabling
    // let clock_contract = deps.querier.query_wasm_contract_info(msg.clock_address.to_string())?;
    // // clock should already exist, and be instantiated by the same covenant contract
    // if Addr::unchecked(clock_contract.creator) != info.sender {
    //     return Err(ContractError::InstantiatorMissmatch {})
    // }

    // avoid zero deposit configurations
    if msg.st_atom_receiver.amount.is_zero() || msg.atom_receiver.amount.is_zero() {
        return Err(NeutronError::Std(
            StdError::GenericErr { msg: "Zero deposit config".to_string() })
        )
    }

    // store the denominations and amounts
    STRIDE_ATOM_RECEIVER.save(deps.storage, &msg.st_atom_receiver)?;
    NATIVE_ATOM_RECEIVER.save(deps.storage, &msg.atom_receiver)?;

    // store the clock address that will be authorized to tick
    CLOCK_ADDRESS.save(deps.storage, &msg.clock_address)?;

    Ok(Response::default())
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> NeutronResult<Response<NeutronMsg>> {
    match msg {
        ExecuteMsg::Tick {} => try_tick(deps, env, info),
        ExecuteMsg::Received {} => try_handle_received(),
    }
}

fn try_tick(deps: DepsMut, env: Env, info: MessageInfo) -> NeutronResult<Response<NeutronMsg>> {
    // retrieve the existing interchain account (s?)
    let gaia_key = ICS_PORT_ID.load(deps.storage)?;
    let gaia_interchain_account = INTERCHAIN_ACCOUNTS.load(
        deps.as_ref().storage, 
        gaia_key
    )?;
    match gaia_interchain_account {
        // if it's the first tick and no ica exist, create an ica
        None => try_register_gaia_ica(deps, env),
        // with an existing ica, proceed to transfers
        Some((_, gaia_account_address)
        ) => try_execute_transfers(deps, info, gaia_account_address),
    }
}

fn try_register_gaia_ica(
    deps: DepsMut,
    env: Env,
) -> NeutronResult<Response<NeutronMsg>> {
    // store the account identifier
    let gaia_acc_id = "gaia-acc";
    // or channel-0..
    let ics_connection_id = "channel-1";
    // register the ica 
    let register = NeutronMsg::register_interchain_account(
        ics_connection_id.to_string(), 
        gaia_acc_id.to_string()
    );

    // Get the IBC port identifier generated by Neutron for the new interchain account.
    let key = get_port_id(env.contract.address.as_str(), &gaia_acc_id);
    ICS_PORT_ID.save(deps.storage, &key)?;
    // Add an incomplete entry for the new account to the storage.
    INTERCHAIN_ACCOUNTS.save(deps.storage, key, &None)?;
    Ok(Response::new().add_message(register))
}

fn try_execute_transfers(
    deps: DepsMut, 
    info: MessageInfo, 
    gaia_account_address: String
) -> NeutronResult<Response<NeutronMsg>> {
    // validate that tick was triggered by the authorized clock
    let clock = CLOCK_ADDRESS.load(deps.as_ref().storage)?;
    if info.sender != clock {
        return Err(NeutronError::Std(
            StdError::GenericErr { msg: "Unauthorized".to_string() })
        )
    }

    let stride_atom_receiver = STRIDE_ATOM_RECEIVER.load(deps.storage)?;
    let native_atom_receiver = NATIVE_ATOM_RECEIVER.load(deps.storage)?;

    // receiving a tick means depositor is ready to attempt to:
    // 1. transfer 1/2 of atoms to liquid-staker module
    // 2. transfer 1/2 of atoms from ICA to liquidity-pooler module

    Ok(Response::default())
}

fn try_handle_received() -> NeutronResult<Response<NeutronMsg>> {

    Ok(Response::default())
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::StAtomReceiver {} => to_binary(&STRIDE_ATOM_RECEIVER.may_load(deps.storage)?),
        QueryMsg::AtomReceiver {} => to_binary(&NATIVE_ATOM_RECEIVER.may_load(deps.storage)?),
        QueryMsg::ClockAddress {} => to_binary(&CLOCK_ADDRESS.may_load(deps.storage)?),
    }
}